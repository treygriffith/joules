{"name":"Joules","tagline":"Node.js-style module loading in the browser","body":"Joules\r\n=========\r\nNode.js-style module loading on the browser optimized for rapid development and robust deployment.\r\n\r\nInstallation\r\n------------\r\n\r\nUsing NPM, pass the `-g` flag to make the `joules` command available on the command line\r\n\r\n```bash\r\n$ npm install joules -g\r\n```\r\n\r\nInstall it in your project's repository to make [deployment builds](#programmatic-build) and [hinting](#hinting) available on the command line\r\n\r\n```bash\r\n$ npm install joules\r\n```\r\n\r\nor clone the repository with Git\r\n\r\n```bash\r\n$ git clone git://github.com/treygriffith/joules.git node_modules/express-render/\r\n```\r\n\r\n\r\nUsage\r\n-----\r\n\r\n### Development\r\n\r\n#### Building the Development Script\r\n\r\nJoules comes with a development script, `joules.js`, in the root directory, but it can be re-built at any time with the `joules-dev` command:\r\n\r\n```bash\r\n$ joules-dev public/js\r\n/Users/username/project/public/js/joules.js written\r\n```\r\n#### Using in your project\r\n\r\nWhen using in development, you just need to add the development script to every page that you want to have module loading support, before any scripts that use modules.\r\n\r\n```html\r\n<html>\r\n\t<head>\r\n\t\t<title>My Cool Webpage</title>\r\n\t</head>\r\n\t<body>\r\n\t\t<p>This is my cool webpage. Welcome!</p>\r\n\t\t<script src=\"/js/joules.js\"></script>\r\n\t\t<script>\r\n\t\t\trequire.ready(function() {\r\n\t\t\t\tvar $ = require('./js/jquery');\r\n\t\t\t\t$(\"p\").text(\"Go Away!\");\r\n\t\t\t});\r\n\t\t</script>\r\n\t</body>\r\n</html>\r\n```\r\n\r\nYou'll notice that when using a script inline on the page, it has to be wrapped in a function that is a callback for `require.ready`, which functions similarly to `$(document).ready` for jQuery, but waits for dependencies to load as opposed to waiting for `domReady`.\r\n\r\n#### Inline Dependency Declaration Limitations\r\n\r\nYou should note that every dependency must be declared within the function body of the callback for `require.ready`. For example, this won't work:\r\n\r\n```html\r\n...\r\n<script>\r\n\t// DON'T DO THIS\r\n\tvar ready = function() {\r\n\t\tvar $ = require('jquery');\r\n\t}\r\n\trequire.ready(function() {\r\n\t\t// no dependencies are declared within the callback function body\r\n\t\tready();\r\n\t});\r\n</script>\r\n...\r\n```\r\n#### Main Entrypoint\r\n\r\nYou can also define a `main` script, which is the primary entry-point for the javascript on the page. Scripts defined externally do not need the `require.ready` callback - they won't be invoked until all dependencies are loaded. For larger web apps, this is usually desirable when compared to inline scripts. This is similar to RequireJS's behavior:\r\n\r\n`index.html`:\r\n\r\n```html\r\n...\r\n<script src=\"/js/joules.js\" data-main=\"/js/main.js\"></script>\r\n....\r\n```\r\n\r\n`main.js`:\r\n\r\n```javascript\r\nvar $ = require('jquery');\r\nvar content = require('./content');\r\n\r\n$(\"p\").text(content);\r\n```\r\n\r\n#### Multiple Scripts\r\n\r\nJoules supports multiple `data-main` scripts (in different script tags) as well as multiple inline script. Each inline script and `data-main` script will have dependencies loaded independently.\r\n\r\n#### Module Lookup\r\n\r\nJoules loads modules using the [same lookup pattern as Node](http://nodejs.org/api/modules.html#modules_modules). In addition, it also looks for HTML files (as index files, and also as exact filenames) that it can scan for inline javascript. The HTML behavior is recommended only when targeting as the base module, not as a way to reference dependencies.\r\n\r\n#### Hinting\r\n\r\nDue to the sometimes lengthy lookup process for modules, using HTTP requests can be burdensome, even in a development environment. To help alleviate the problem, Joules provides a way to generate a hinting file for your public directory to reduce HTTP requests.\r\n\r\nIf you're using Node.js, the hinting file is generated as follows:\r\n\r\n```javascript\r\n// public is the directory from which our static assets are served\r\njoules.hint('./public', function(err) {\r\n\tif(err) throw err;\r\n\tconsole.log(\"hinting file created.\");\r\n});\r\n```\r\n\r\nThis command automatically watches the `./public` directory for any changes, and will update the hinting file appropriately, allowing you to keep the same rapid development environment without tons of HTTP requests.\r\n\r\n### Deployment\r\nTo serve your modules as a compiled bundle that is optimized for deployment, you can use the command line builder, or the programmatic version of the same tool for use in a larger build process.\r\n\r\nTo build a script, you simply have to define a target. The target can be an HTML file, which will be scanned for inline javascript, or the main entrypoint to your program, like `main.js` in the development section.\r\n\r\n#### Command Line Build\r\n\r\n```bash\r\n$ joules ./js/main.js\r\nmain.joules.js written.\r\n```\r\n\r\nBy default, Joules outputs a file called `target.joules.js` where `target` is the target module or filename, in the same directory as the target module or file. This can be modified by passing the `out` flag.\r\n\r\n```bash\r\n$ joules ./js/main.js --out ./js/bundle.js\r\nbundle.js written.\r\n```\r\n\r\n#### Programmatic Build\r\n\r\nFor using Joules as part of a larger build process, require the Joules module:\r\n\r\n```javascript\r\nvar joules = require('joules');\r\njoules.build('./js/main.js', function(err, script) {\r\n\tfs.writeFileSync('./js/my-bundle.js', script, 'utf8');\r\n});\r\n```\r\n\r\n#### Using in your project\r\n\r\nOnce you've built your bundled file, you can include it like any regular script on the page. To borrow examples from the deployment section:\r\n\r\nTargeting an external script, `main.js`:\r\n\r\n```html\r\n<html>\r\n\t<head>\r\n\t\t<title>My Cool Webpage</title>\r\n\t</head>\r\n\t<body>\r\n\t\t<p>This is my cool webpage. Welcome!</p>\r\n\t\t<script src=\"/js/main.joules.js\"></script>\r\n\t</body>\r\n</html>\r\n```\r\n\r\nTargeting the inline script for this page, `index.html`:\r\n\r\n```html\r\n<html>\r\n\t<head>\r\n\t\t<title>My Cool Webpage</title>\r\n\t</head>\r\n\t<body>\r\n\t\t<p>This is my cool webpage. Welcome!</p>\r\n\t\t<script src=\"/js/index.joules.js\"></script>\r\n\t</body>\r\n</html>\r\n```\r\n\r\n\r\nWhy Modules?\r\n------------\r\nIf you've ever developed anything significant in front-end Javascript, you know that dependency handling is a pain. Add in to that the inherent problems with Javascript's global namespacing defaults and any complex project will quickly get bogged down.\r\n\r\nModules are a way to separate Javascript code into logical chunks that can be depended upon by other modules. If you've ever programmed in another paradigm (including SSJS), modules are a clearly lacking feature of client-side Javascript.\r\n\r\n\r\nWhy not use RequireJS?\r\n---------------------\r\n(or another AMD module loader)\r\n\r\nThe CommonJS Module loading standard (or rather, Node's \"interpretation\" of the standard) is a more comfortable way to include dependencies, and has tons of traction on the server side. From a module perspective, it is by far the largest ecosystem out there, so it makes sense to maximize browser modules with Node-style modules.\r\n\r\nAMD works well for what it's for, which is asynchronous module-loading on the web. However the javascript ecosystem is much larger than that, and I think that by limiting use to the browser only, it's limiting its usefulness to developers.\r\n\r\nAMD requires that module developers include a bunch of boilerplate in their projects, which doesn't make sense for maximum compatibility.\r\n\r\nIn addition to the clunky syntax it forces on you, RequireJS in particular also forces you to have a certain project hierarchy for scripts. While practical in terms of reducing I/O, I think a module loader should be unopinionated in terms of project structure.\r\n\r\n\r\nWhy not use Browserify?\r\n-----------------------\r\n\r\nBrowserify is a great project and one of the big inspirations for this project. However, one of the things that I think RequireJS got right was the development environment - devs want to be able to rapidly change code and see results. Browserify requires a build step, and while a build step is important for a production environment to maximize end-user speed and minimize server load, for development a build step is detrimental to developer speed.\r\n\r\nThat said, the work that Browserify has done on translating Node's core modules for the web is excellent, and I hope to incorporate those into this project as well as extend them where possible.\r\n\r\n\r\nWhy Joules?\r\n-----------------------\r\n\r\nMy hope is that by taking advantage of the primary strengths of the two leading Javascript browser module loaders, RequireJS and Browserify, I can produce an experience that is ultimately better for developers.\r\n\r\nIt takes the strength of the CommonJS/Node.js module system and community (like Browserify), and puts it into an browser environment that is suitable for rapid development as well as robust deployment (like RequireJS).\r\n\r\nWhen CommonJS was first discussed, the browser was supposed to have stop-gap measures until module loading was natively supported. Those stop-gap measures were:\r\n1) Either use a server to translate CJS modules to something usable in the browser.\r\n2) Or use XMLHttpRequest (XHR) to load the text of modules and do text transforms/parsing in browser.\r\n\r\nThis implementation does both, using (1) for deployment builds, and (2) for development.\r\n\r\nFeatures\r\n--------\r\n\r\n* CommonJS/Node.js style module loading (`var module = require('module')`) without requiring a build step.\r\n\r\n* A Node.js-like execution environment - makes for easy transfer of modules\r\n\r\n* Supports [`node_modules` modules](http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders) as well as [files as modules](http://nodejs.org/api/modules.html#modules_file_modules) and [directories as modules](http://nodejs.org/api/modules.html#modules_folders_as_modules)\r\n\r\n* Ability to use NPM and other Node.js package management tools to manage packages for the front-end, with occasional minor adjustments for browser vs. server behavior\r\n\r\n* Inline scripting supported via `require.ready` callback similar to the `$.ready` jQuery callback\r\n\r\n* Scripts are fetched asynchronously in development, and are pre-compiled in deployment, but are always guaranteed to be available prior to script execution\r\n\r\n* No global namespace pollution (all globals must be explicitly attached to the `window` object, or the semi-global `global` object)\r\n\r\n* Supports a `data-main` attribute as the script's entry point (like RequireJS)\r\n\r\n* Compile-time dependency determination - no need to state them up front\r\n\r\n* [Circular dependency support](http://nodejs.org/api/modules.html#modules_cycles)\r\n\r\n* Build script is nearly identical to development script, leading to fewer differences between dev and deployment\r\n\r\nIssues\r\n------\r\nThere are several issues with Joules that do not come up or are better supported by other browser module loaders.\r\n\r\n* file:// usage - due to how many browser vendors implement Cross-domain whitelisting, you cannot xhr a file:// location, even if it's from a file:// location. That means that when using Joules in development, you have to spin up a server. Since most development work happens this way anyway, this is viewed as an acceptable sacrifice, but it is a limitation.\r\n\r\n* Cross-domain/CDN usage - when using Joules in development, any CDN or other domain you use (e.g. your production domain) has to include the appropriate [CORS header](https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS#Access-Control-Allow-Origin) to allow your local development environment access. This is one-time setup, but might be a difference maker depending on your CDN.\r\n\r\n* Debugging - using Joules in both development and deployment transforms your scripts in such a way that errors will not be thrown in your source file. For simple debugging it is serviceable, but for more complex web apps a better solution is needed. Some browsers are beginning to implement Source maps, which Joules will support (eventually) which should help with debugging, but it is not yet widely supported.\r\n\r\n* Inline scripts are not cross-browser - Joules supports inline scripts that are housed inside of a `require.ready()` callback. It uses `Function.prototype.toString()` to parse out the `require` dependencies. This behavior is not 100% cross-browser, but is only used in development (for deployment you can specifically target HTML files that contain inline scripts).\r\n\r\n* Variable `require`s - Both the development and deployment environments rely on RegExp parsing to determine dependencies via `require` calls. Therefore any call to `require` with a variable value (or any value that is not a string literal) will at best not return a module, and at worst choke the parser. Generally this is an undesirable design in any case, and can be better replaced with variability within in the `require`d module.\r\n\r\n* Multiple I/O calls - In the development environment, the browser makes multiple I/O calls in the form of HEAD requests in an attempt to find modules in a way that is consistent with Node.js's search pattern. While this is usually acceptable in a server environment, on the browser this can lead to performance slowdowns when there are a large number of modules, and can clutter the debugger with pointless 404's. To mitigate this, you can enable [server-side hinting](#hinting) to provide the front-end with information about the directory structure, which significantly speeds up development loading and gets rid of 404 errors, but doesn't completely get rid of I/O.\r\n\r\n* Delayed execution - because the CommonJS style `require` expects an immediate return value instead of a callback, every dependency (and by extension, each dependency's depdendency on down the chain) must be available as soon as any code in one sandbox is executed. In practice this means slower start times, as every single dependency, regardless of how soon it will be needed, must be loaded. This is mitigated in the deployment version where all the scripts are bundled, but is still an issue.\r\n\r\n* Circular Dependencies in node_modules - The current way that circular dependencies are detected in the source code is flawed when working with using modules required by name. This issue is being actively worked.\r\n\r\nLicense\r\n-------\r\n\r\nMIT - [View Full License](LICENSE)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}